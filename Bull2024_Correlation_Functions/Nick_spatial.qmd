---
title: Spatial correlation functions
description: "Go over the paper: Extended correlation functions for spatial analedysis of multiplex imaging data, Bull et al. 2024"
authors:
  - name: Nicholas Harbour
format: 
  html:
    embed-resources: true
    code-fold: true
    number-sections: true
    toc: true
    toc-depth: 3
    date-modified: last-modified
    date-format: "MMMM DD, YYYY, HH:mm:ss"
jupyter: python3
---

```{python}

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns


```

```{python}



def simulate_poisson_point_process(lambda_, width=1.0, height=1.0, seed=42):

    np.random.seed(seed)
    
    area = width * height
    # Number of points follows a Poisson distribution
    n_points = np.random.poisson(lambda_ * area)
    
    # Uniformly distribute the points in the rectangle
    x = np.random.uniform(0, width, n_points)
    y = np.random.uniform(0, height, n_points)
    
    return x, y

```

# Complete spatial randomness - poisson point process

```{python}

# Example usage
lam = 500  # intensity (points per unit area)
x, y = simulate_poisson_point_process(lam, width=1.0, height=1.0, seed=42)

# Plot
plt.scatter(x, y, c='blue', s=10, alpha=0.6)
plt.title(f"Homogeneous Spatial Poisson Point Process (lam={lam})")
plt.xlim(0, 1)
plt.ylim(0, 1)
plt.grid(True, linestyle='--', alpha=0.5)
plt.show()

points = np.vstack((x, y)).T

```

Lets randomly assign labels to each point

```{python}


cat_labs = np.random.choice([0, 1], size=len(x))

plt.plot(x[cat_labs == 0], y[cat_labs == 0], 'o', color='blue', markersize=5, alpha=0.6, label='Category 0')
plt.plot(x[cat_labs == 1], y[cat_labs == 1], 'o', color='red', markersize=5, alpha=0.6, label='Category 1')
plt.title(f"Random Assignment of Labels")

```


Pair cross correlation function (PCF)

```{python}

# distance bins to consider
dr = 0.01 
r = np.arange(0.01, 0.5, dr) 

width = 1.0
height = 1.0

# calulare all pairwise distances between 2 sets of points
def calc_pairwise_distances(points1, points2):
    x1 = points1[:, 0]
    y1 = points1[:, 1]
    x2 = points2[:, 0]
    y2 = points2[:, 1]
    dists = np.zeros((len(x1), len(x2)))
    for i in range(len(x1)):
        for j in range(len(x2)):
            dists[i, j] = np.sqrt((x1[i] - x2[j])**2 + (y1[i] - y2[j])**2)
    
    return dists

# idicator function
def r_idicator(dist,a,b):
    '''
    I_[a,b](r) = 1 if a <= r < b else 0
    '''
    if dist >= a and dist < b:
        return 1
    else:
        return 0

def categroy_idicator(cat_labs, cat):
    '''
    I_[cat](cat_labs) = 1 if cat_labs == cat else 0
    '''
    if cat_labs == cat:
        return 1
    else:
        return 0

# Area of circle / annualus with min a and max b
def A_r(r,dr):
    return np.pi*(2*r+dr)*dr



def crossPCF(r,points,cat_labs):

    # Extract x and y coordinates from points
    x = points[:, 0]
    y = points[:, 1]

    # Total number of points/cells with each label
    N_c0 = len(x[cat_labs == 0])
    N_c1 = len(x[cat_labs == 1])

    # In total there will be len(x) * len(y) pair wise distances
    # Calc pairwise distances between points of different categories
    pair_dist = calc_pairwise_distances(points[cat_labs == 0], points[cat_labs == 1])

    A = width * height

    dr = r[1] - r[0]
    g_c1c2 = np.zeros(len(r))

    for k in range(len(r)):
        count = 0

        # Loop over all points in category 1 and category 2
        for i in range(len(points[cat_labs == 0])):
            for j in range(len(points[cat_labs == 1])):
            
                #
                count = count + r_idicator(pair_dist[i,j] - r[k] , 0, dr)*categroy_idicator(cat_labs[j], 1)*categroy_idicator(cat_labs[i], 0)
        
        
        shell_area = A_r(r[k], dr)
        g_c1c2[k] = (1 / (N_c0*N_c1)) *  A * (count / shell_area)
            


    return g_c1c2

test = crossPCF(r, points, cat_labs)
print(test)

```

plot the corss pcf next to the points

```{python}

fig, ax = plt.subplots(1,2, figsize=(12, 6))


ax[0].plot(x[cat_labs == 0], y[cat_labs == 0], 'o', color='blue', markersize=5, alpha=0.6, label='Category 0')
ax[0].plot(x[cat_labs == 1], y[cat_labs == 1], 'o', color='red', markersize=5, alpha=0.6, label='Category 1')
ax[0].set_title(f"Random Assignment of Labels")
ax[0].legend()

ax[1].plot(r, test, 'o-', color='blue', markersize=5, alpha=0.6, label='Category 0')
ax[1].set_title(f"Cross PCF")

```


# Clustered spatial point process

```{python}


np.random.seed(42)
# generate 5 cluster centers
cluster_centers = np.random.uniform(0.1, 0.9, size=(5, 2))

# at each cluster center genrate 20 guassian points
n_points = 50
for i in range(len(cluster_centers)):
    x = np.random.normal(loc=cluster_centers[i, 0], scale=0.025, size=n_points)
    y = np.random.normal(loc=cluster_centers[i, 1], scale=0.025, size=n_points)
    if i == 0:
        all_x = x
        all_y = y
    else:
        all_x = np.concatenate((all_x, x))
        all_y = np.concatenate((all_y, y))

# Randomlt assign labels to each point
clustered_cat_labs = np.random.choice([0, 1], size=len(all_x))



plt.plot(cluster_centers[:, 0], cluster_centers[:, 1], '*', color='m', markersize=15, alpha=1, label='Cluster Centers')
plt.plot(all_x[clustered_cat_labs == 0], all_y[clustered_cat_labs == 0], 'o', color='blue', markersize=5, alpha=0.3, label='Category 0')
plt.plot(all_x[clustered_cat_labs == 1], all_y[clustered_cat_labs == 1], 'o', color='red', markersize=5, alpha=0.3, label='Category 1')

plt.xlim(0, 1)
plt.ylim(0, 1)

```


cross PCF


```{python}

points_clustered = np.vstack((all_x, all_y)).T
test = crossPCF(r, points_clustered, clustered_cat_labs)
print(test)
fig, ax = plt.subplots(1,2, figsize=(12, 6))
ax[0].plot(all_x[clustered_cat_labs == 0], all_y[clustered_cat_labs == 0], 'o', color='blue', markersize=5, alpha=0.6, label='Category 0')
ax[0].plot(all_x[clustered_cat_labs == 1], all_y[clustered_cat_labs == 1], 'o', color='red', markersize=5, alpha=0.6, label='Category 1')
ax[0].set_title(f"Random Assignment of Labels")
ax[0].legend()


ax[1].plot(r, test, 'o-', color='black', markersize=5, alpha=0.6, label='Category 0')
ax[1].axhline(1, color='grey', linestyle='--')
ax[1].set_title(f"Cross PCF")


```