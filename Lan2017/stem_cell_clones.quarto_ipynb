{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Stem cell clones\n",
        "description: Simulate the stem cell clonal dynamics\n",
        "authors:\n",
        "  - name: Markus Owen\n",
        "format: \n",
        "  html:\n",
        "    embed-resources: true\n",
        "    code-fold: true\n",
        "    number-sections: true\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    date: now\n",
        "    date-modified: last-modified\n",
        "    date-format: \"MMMM DD, YYYY, HH:mm:ss\"\n",
        "jupyter: python3\n",
        "---\n",
        "\n",
        "\n",
        "# import packages and define functions\n"
      ],
      "id": "2258f06a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| label: Import_packages\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import pandas as pd\n",
        "from numpy.random import default_rng\n",
        "import math"
      ],
      "id": "Import_packages",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Define functions \n"
      ],
      "id": "2a6c90ab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def simulate_model0(omega,lam,tmax,rng_seed):\n",
        "\n",
        "    # simulation parameters\n",
        "    nt = 100000\n",
        "\n",
        "    ## reset the random number generator and initialise using RNG_SEED\n",
        "    rng = default_rng(rng_seed)\n",
        "\n",
        "    ## initialise the stoichiometric matrix\n",
        "    # rows are state variables\n",
        "    # columns are reactions\n",
        "    nvariables = 2\n",
        "    nreactions = 3\n",
        "    stoichiometry = np.array([[0,0,0],[1,1,-1]])\n",
        "\n",
        "    S0 = 1\n",
        "    P0 = 0\n",
        "\n",
        "    ## initialise time, the state variables \n",
        "    # order is O, C\n",
        "    # variables stored as a matrix with one column per time point\n",
        "    t = np.zeros(nt)\n",
        "    variables = np.zeros((nvariables,nt))\n",
        "    variables[:,:1]=np.array([[S0],[P0]])\n",
        "\n",
        "    ## time loop\n",
        "    j = 0;\n",
        "    while t[j] < tmax and j < nt-1:\n",
        "        S = variables[0,j]\n",
        "        P = variables[1,j]\n",
        "        rates = np.array([omega*S,0.5*lam*P,0.5*lam*P])\n",
        "        rtot = rates.sum()\n",
        "        t[j+1] = t[j] - math.log(1-rng.uniform())/rtot\n",
        "        # uniform random number in [0,rtot)\n",
        "        rtot_rand = rtot*rng.uniform()\n",
        "        # cumsum gives the cumulative sum, [rates(1) rates(1)+rates(2) ...]\n",
        "        r = rates.cumsum()\n",
        "        # reaction: first interval end point that rtot_rand is less than\n",
        "        reaction = np.searchsorted(r,rtot_rand)\n",
        "        # update the state\n",
        "        variables[:,j+1] = variables[:,j] + stoichiometry[:,reaction]\n",
        "        j = j + 1\n",
        "\n",
        "    # ignore empty entries in t, O, C\n",
        "    t = t[0:j]\n",
        "    S = variables[0,0:j];\n",
        "    P = variables[1,0:j];\n",
        "    final_size = S[-1]+P[-1]\n",
        "\n",
        "    return t,S,P,final_size"
      ],
      "id": "101017bb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def simulate_model(omega,epsilon,lam,Gamma,tmax,rng_seed):\n",
        "\n",
        "    # simulation parameters\n",
        "    nt = 100000\n",
        "\n",
        "    ## reset the random number generator and initialise using RNG_SEED\n",
        "    rng = default_rng(rng_seed)\n",
        "\n",
        "    ## initialise the stoichiometric matrix\n",
        "    # rows are state variables\n",
        "    # columns are reactions\n",
        "    nvariables = 3\n",
        "    nreactions = 5\n",
        "    stoichiometry = np.array([[1,0,0,0,0],[0,1,1,-1,0],[0,0,0,1,-1]])\n",
        "\n",
        "    S0 = 1\n",
        "    P0 = 0\n",
        "    D0 = 0\n",
        "\n",
        "    # plt.figure(figsize = (8, 8))\n",
        "\n",
        "    ## initialise time, the state variables \n",
        "    # order is O, C\n",
        "    # variables stored as a matrix with one column per time point\n",
        "    t = np.zeros(nt)\n",
        "    variables = np.zeros((nvariables,nt))\n",
        "    variables[:,:1]=np.array([[S0],[P0],[D0]])\n",
        "\n",
        "    ## time loop\n",
        "    j = 0;\n",
        "    while t[j] < tmax and j < nt-1:\n",
        "        S = variables[0,j]\n",
        "        P = variables[1,j]\n",
        "        D = variables[2,j]\n",
        "        rates = np.array([epsilon*omega*S,(1-epsilon)*omega*S,0.5*lam*P,0.5*lam*P,Gamma*D])\n",
        "        rtot = rates.sum()\n",
        "        t[j+1] = t[j] - math.log(1-rng.uniform())/rtot\n",
        "        # uniform random number in [0,rtot)\n",
        "        rtot_rand = rtot*rng.uniform()\n",
        "        # cumsum gives the cumulative sum, [rates(1) rates(1)+rates(2) ...]\n",
        "        r = rates.cumsum()\n",
        "        # reaction: first interval end point that rtot_rand is less than\n",
        "        reaction = np.searchsorted(r,rtot_rand)\n",
        "        # update the state\n",
        "        variables[:,j+1] = variables[:,j] + stoichiometry[:,reaction]\n",
        "        j = j + 1\n",
        "\n",
        "    # ignore empty entries in t, O, C\n",
        "    t = t[0:j]\n",
        "    S = variables[0,0:j];\n",
        "    P = variables[1,0:j];\n",
        "    D = variables[2,0:j];\n",
        "    final_size = S[-1]+P[-1]+D[-1]\n",
        "\n",
        "    return t,S,P,D,final_size"
      ],
      "id": "08271c2d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def simulate_model2(lam,delta,tmax,rng_seed):\n",
        "\n",
        "    # simulation parameters\n",
        "    nt = 20000\n",
        "\n",
        "    ## reset the random number generator and initialise using RNG_SEED\n",
        "    rng = default_rng(rng_seed)\n",
        "\n",
        "    ## initialise the stoichiometric matrix\n",
        "    # rows are state variables\n",
        "    # columns are reactions\n",
        "    nvariables = 1\n",
        "    nreactions = 2\n",
        "    stoichiometry = np.array([[1,-1]])\n",
        "\n",
        "    S0 = 1\n",
        "\n",
        "    # plt.figure(figsize = (8, 8))\n",
        "\n",
        "    ## initialise time, the state variables is just S\n",
        "    # variables stored as a matrix with one column per time point\n",
        "    t = np.zeros(nt)\n",
        "    variables = np.zeros((nvariables,nt))\n",
        "    variables[:,:1]=np.array([[S0]])\n",
        "\n",
        "    ## time loop\n",
        "    j = 0;\n",
        "    while t[j] < tmax and j < nt-1:\n",
        "        S = variables[0,j]\n",
        "        rates = np.array([lam*(0.5+delta)*S,lam*(0.5-delta)*S])\n",
        "        rtot = rates.sum()\n",
        "        t[j+1] = t[j] - math.log(1-rng.uniform())/rtot\n",
        "        # uniform random number in [0,rtot)\n",
        "        rtot_rand = rtot*rng.uniform()\n",
        "        # cumsum gives the cumulative sum, [rates(1) rates(1)+rates(2) ...]\n",
        "        r = rates.cumsum()\n",
        "        # reaction: first interval end point that rtot_rand is less than\n",
        "        reaction = np.searchsorted(r,rtot_rand)\n",
        "        # update the state\n",
        "        variables[:,j+1] = variables[:,j] + stoichiometry[:,reaction]\n",
        "        j = j + 1\n",
        "\n",
        "    # ignore empty entries in t, O, C\n",
        "    t = t[0:j]\n",
        "    S = variables[0,0:j];\n",
        "    final_size = S[-1]\n",
        "\n",
        "    return t,S,final_size"
      ],
      "id": "3c3a4e4e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def size_freq_stats(final_size):\n",
        "    size_freq_order = pd.Series(final_size).value_counts(normalize=True)\n",
        "    size_freq = pd.Series.sort_index(size_freq_order)\n",
        "    size_freq_mean = np.sum(size_freq.index*np.transpose(size_freq.values))\n",
        "    mu_n = (size_freq_mean - np.cumsum(size_freq.index*np.transpose(size_freq.values)))/size_freq_mean\n",
        "    return size_freq,size_freq_mean,mu_n"
      ],
      "id": "fd1780af",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Run different models \n",
        "\n",
        "## Set common parameters\n"
      ],
      "id": "9e07f18f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "nsims = 10000\n",
        "tmax = 80"
      ],
      "id": "702b1eff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Initial model: One Stem cell, Progenitors and Differentiated \n",
        "\n",
        "Illustrative simulations. \n"
      ],
      "id": "7285a40b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "final_size0 = np.zeros((100))\n",
        "# model parameters\n",
        "omega = 0.15 # S division rate per day\n",
        "lam = 1 # P division rate per day\n",
        "tmax = 80\n",
        "\n",
        "for isim in range(100): \n",
        "    t,S,P,final_size0[isim] = simulate_model0(omega,lam,tmax,isim)\n",
        "    plt.step(t,S+P,where='post')\n",
        "\n",
        "plt.title('Initial model: Clonal dynamics')\n",
        "tt = np.linspace(0,tmax,201)\n",
        "plt.plot(tt,1+omega*tt)\n",
        "plt.ylabel('S(t)+P(t)')\n",
        "plt.title(f'Illustrative solutions: Initial model')\n",
        "# plt.legend()\n",
        "plt.show()"
      ],
      "id": "c2d38264",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "final_size0 = np.zeros((nsims))\n",
        "\n",
        "for isim in range(nsims): \n",
        "    t,S,P,final_size0[isim] = simulate_model0(omega,lam,tmax,isim)"
      ],
      "id": "a5e51be3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Stem cell / Progenitor / Differentiated model\n",
        "\n",
        "Illustrative solutions. \n"
      ],
      "id": "7c95a4f5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# model parameters\n",
        "epsilon = 0.15\n",
        "omega = 0.15 # S division rate per day\n",
        "lam = 1 # P division rate per day\n",
        "Gamma = 0.5 # Differentiated cell apoptosis rate per day\n",
        "\n",
        "for isim in range(100): \n",
        "    t,S,P,D,_ = simulate_model(omega,epsilon,lam,Gamma,tmax,isim)\n",
        "    plt.plot(t,S+P+D)\n",
        "\n",
        "plt.xlabel('t [days]')\n",
        "plt.ylabel('S(t)+P(t)+D(t)')\n",
        "plt.title('Illustrative solutions of S-P-D model')\n",
        "plt.show()"
      ],
      "id": "4488df1f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "final_size = np.zeros((nsims))\n",
        "\n",
        "for isim in range(nsims): \n",
        "    t,S,P,D,final_size[isim] = simulate_model(omega,epsilon,lam,Gamma,tmax,isim)\n",
        "\n",
        "# plt.subplot(311)\n",
        "# plt.step(t,S,where='post',label='S(t)')\n",
        "# plt.title(f'Clonal dynamics at t={t[-1]}')\n",
        "# plt.ylabel('S(t)')\n",
        "# # plt.legend()\n",
        "# plt.subplot(312)\n",
        "# plt.step(t,P,where='post',label='P(t)')\n",
        "# plt.ylabel('P(t)')\n",
        "# # plt.legend()\n",
        "# plt.subplot(313)\n",
        "# plt.step(t,D,where='post',label='D(t)')\n",
        "# plt.ylabel('D(t)')\n",
        "# # plt.legend()\n",
        "\n",
        "# plt.show()"
      ],
      "id": "0019c87f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Heterogeneous exponential growth\n",
        "\n",
        "Illustrative simulations. \n"
      ],
      "id": "d81416d3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "lam = 1\n",
        "\n",
        "plt.figure(figsize = (8, 8))\n",
        "\n",
        "rng = default_rng(1)\n",
        "\n",
        "final_size_het = np.zeros((1000))\n",
        "\n",
        "for isim in range(100): \n",
        "    delta = 0.02+0.0*rng.uniform()\n",
        "    t,S,final_size_het[isim] = simulate_model2(lam,delta,tmax,isim)\n",
        "    print(isim,delta,t[-1],S[-1])\n",
        "    plt.step(t,S,where='post')\n",
        "\n",
        "plt.title(f'Illustrative solutions: Heterogeneous exponential growth')\n",
        "plt.ylabel('S(t)')\n",
        "# plt.legend()\n",
        "plt.show()"
      ],
      "id": "02d79cb1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "final_size_het = np.zeros((nsims))\n",
        "\n",
        "for isim in range(nsims): \n",
        "    delta = 0.02+0.0*rng.uniform()\n",
        "    t,S,final_size_het[isim] = simulate_model2(lam,delta,tmax,isim)"
      ],
      "id": "6dfb8637",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Analyse final size frequencies\n"
      ],
      "id": "6781223d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "size_freq_spd,size_freq_mean_spd,mu_n_spd=size_freq_stats(final_size)\n",
        "\n",
        "size_freq_0,size_freq_mean_0,mu_n_0=size_freq_stats(final_size0)\n",
        "\n",
        "size_freq_het,size_freq_mean_het,mu_n_het=size_freq_stats(final_size_het)"
      ],
      "id": "86509d35",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Try plotting with log scale on y-axis: "
      ],
      "id": "d0f6d046"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "lam = 1\n",
        "n0 = lam*tmax/2\n",
        "N0 = np.log(n0)\n",
        "\n",
        "n0_spd = 2*size_freq_mean_spd # no justification for this scaling\n",
        "N0_spd = 0.5*np.log(n0_spd) # no justification for this scaling\n",
        "\n",
        "ss = np.linspace(0.1,500,101)\n",
        "\n",
        "plt.semilogy(ss,np.exp(-ss/n0)/(N0*ss),label='Negative binomial')\n",
        "plt.semilogy(ss,np.exp(-ss/n0_spd)/(N0_spd*ss),label='Negative binom (SPD)?')\n",
        "plt.semilogy(size_freq_0,'.',label='Initial model')\n",
        "plt.semilogy(size_freq_spd,'.',label='Stem-Progenitor model')\n",
        "plt.semilogy(size_freq_het,'.',label='Heterogeneity model')\n",
        "plt.xlabel('Final size')\n",
        "plt.ylabel('Frequency')\n",
        "plt.ylim((0.00009,1.1))\n",
        "plt.legend()"
      ],
      "id": "745e484a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plt.semilogy(ss,np.exp(-ss/(n0)),label='Negative binomial (initial model)')\n",
        "plt.semilogy(ss,np.exp(-ss/n0_spd),label='Negative binom (SPD)?')\n",
        "plt.semilogy(mu_n_0,'.',label='Initial model')\n",
        "plt.semilogy(mu_n_spd,'.',label='Stem-Progenitor model')\n",
        "plt.semilogy(mu_n_het,'.',label='Heterogeneity model')\n",
        "plt.xlabel('Final size')\n",
        "plt.ylabel('First incomplete moment')\n",
        "plt.ylim((0.001,1.1))\n",
        "plt.legend()"
      ],
      "id": "ada233b8",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\pmxcb7\\AppData\\Local\\Programs\\Python\\Python313\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}