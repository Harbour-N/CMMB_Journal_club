---
title: Scott 2021 3D persistent random walks
authors:
  - name: Markus Owen
format: 
  html:
    embed-resources: true
    code-fold: true
    number-sections: true
    toc: true
    toc-depth: 3
    date: now
    date-modified: last-modified
    date-format: "MMMM DD, YYYY, HH:mm:ss"
  pdf: 
    number-sections: true
    colorlinks: true
execute:
  echo: true
jupyter: python3
---

# Introduction

A mathematical framework for modelling 3D cell motility: applications to glioblastoma cell migration, M Scott, K Żychaluk, R N Bearon [https://doi.org/10.1093/imammb/dqab009](https://doi.org/10.1093/imammb/dqab009). 

```{python}
import numpy as np
import matplotlib.pyplot as plt
from scipy import stats
```

```{python}
def simulate_prw_aoup_3d(n_steps, dt, tau, D_v,
                         x0=None, v0=None, seed=None,
                         return_velocities=False):
    """
    3D persistent random walk with OU velocity (Active Ornstein–Uhlenbeck Particle).
    SDE:
        dx = v dt
        dv = -(1/tau) v dt + sqrt(2 D_v) dW

    Parameters
    ----------
    n_steps : int
        Number of time steps.
    dt : float
        Time step size.
    tau : float
        Velocity correlation time.
    D_v : float
        Velocity noise intensity (units: v^2 / time).
        Stationary per-component variance is D_v * tau.
    x0 : array-like shape (3,), optional
        Initial position (default [0,0,0]).
    v0 : array-like shape (3,), optional
        Initial velocity (default draws from stationary distribution).
    seed : int, optional
        Random seed.
    return_velocities : bool
        If True, also return velocity array.

    Returns
    -------
    t : (n_steps+1,) array
        Time points.
    X : (n_steps+1, 3) array
        Trajectory positions.
    V : (n_steps+1, 3) array, optional
        Velocities (if return_velocities=True).
    """
    rng = np.random.default_rng(seed)
    t = np.linspace(0.0, n_steps * dt, n_steps + 1)
    X = np.zeros((n_steps + 1, 3), dtype=float)
    V = np.zeros_like(X)

    if x0 is not None:
        X[0] = np.asarray(x0, dtype=float)

    # Initialize velocity
    if v0 is None:
        # Draw from stationary Gaussian: N(0, D_v * tau I)
        V[0] = np.sqrt(D_v * tau) * rng.normal(size=3)
        V[0] = np.sqrt(3*D_v*tau) * V[0] / np.sqrt(V[0] @ V[0])
    else:
        V[0] = np.asarray(v0, dtype=float)

    # Exact OU update coefficients
    a = np.exp(-dt / tau)
    var_inc = D_v * tau * (1.0 - a**2)  # per component
    sigma = np.sqrt(var_inc)

    for k in range(n_steps):
        # Exact OU step for velocity
        V[k + 1] = a * V[k] + sigma * rng.normal(size=3)
        # Position update (explicit Euler with current velocity)
        X[k + 1] = X[k] + V[k] * dt

    if return_velocities:
        return t, X, V
    return t, X
```

Model in the paper: 
$$
d\mathbf{v}=-\frac{1}{P} \mathbf{v} dt + \sqrt{\frac{2S^2}{3P}} d \mathbf{W}(t)
$$

Model in the code (same model, different parameters but with defined equivalence): 
$$
d\mathbf{v}=-\frac{1}{\tau} \mathbf{v} dt + \sqrt{2 D_v} d \mathbf{W}(t)
$$

$D_v$ here is the white noise intensity in velocity, so not a diffusion coefficient in the $L^2/T$ sense of *positional diffusion*. 

So we equate $\tau=P$ and $D_v=S^2/3P$. 

For $P=1$, $S=1$ we have $\tau=1$, $D_v=1/3$. 

Speed should follow Maxwell-Boltzmann distribution with density 

$$
f(u;S) = \left(\frac{3}{2\pi S^2}\right)^{3/2} 4 \pi u^2 e^{-\frac{3u^2}{2S^2}}
$$

Mean is 

$$
\mu = 2a \sqrt{\frac{2}{\pi}} = 2\frac{S}{\sqrt{3}} \sqrt{\frac{2}{\pi}}
$$

```{python}
S = 1
P = 1
tau = P
D_v = S**2/(3*P)
dt = 0.05

from mpl_toolkits.mplot3d import Axes3D  # ensures 3D projection is registered


# --- Example B: OU velocity ---
t2, X2, V2 = simulate_prw_aoup_3d(
    n_steps=1000, dt=dt, tau=tau, D_v=D_v, return_velocities=True, seed=7
)

fig = plt.figure(figsize=(7, 6))
ax = fig.add_subplot(111, projection='3d')
ax.plot(X2[:, 0], X2[:, 1], X2[:, 2], lw=1.0, color='tab:orange')
ax.scatter(X2[0, 0], X2[0, 1], X2[0, 2], color='green', s=30, label='start')
ax.scatter(X2[-1, 0], X2[-1, 1], X2[-1, 2], color='red', s=30, label='end')
ax.set_title("3D PRW: Active Ornstein–Uhlenbeck Velocity")
ax.set_xlabel("x")
ax.set_ylabel("y")
ax.set_zlabel("z")
ax.legend()
plt.tight_layout()
plt.show()
```

```{python}
nsims = 1000
n_steps = 1000
fig = plt.figure(figsize=(7, 6))
ax = fig.add_subplot(111, projection='3d')

x_end_store = np.empty((nsims,3))
sd_store = np.empty((n_steps+1,nsims))
ss_store = np.empty((n_steps+1,nsims))
vacf_store = np.empty((n_steps+1,nsims))

for i in np.arange(0,nsims):
  t2, X2, V2 = simulate_prw_aoup_3d(
    n_steps=n_steps, dt=dt, tau=tau, D_v=D_v, return_velocities=True, seed=i
    )
  ax.plot(X2[:, 0], X2[:, 1], X2[:, 2], lw=1.0)
  ax.scatter(X2[0, 0], X2[0, 1], X2[0, 2], color='green', s=30, label='start')
  ax.scatter(X2[-1, 0], X2[-1, 1], X2[-1, 2], color='red', s=30, label='end')
  ax.set_title("3D PRW: Active Ornstein–Uhlenbeck Velocity")
  ax.set_xlabel("x")
  ax.set_ylabel("y")
  ax.set_zlabel("z")
  x_end_store[i,:]=X2[-1,:]
  # store the squared displacement at each time point for each trajectory
  sd_store[:,i] = np.sum(X2**2,axis=1)
  # store the squared speed at each time point for each trajectory
  ss_store[:,i] = np.sum(V2**2,axis=1)
  # store the autocorrelation of velocity with v(0)
  vacf_store[:,i] = V2 @ V2[0,:]

# ax.legend()
plt.tight_layout()
plt.show()
```

MSD should be $2 S^2 P^2 \left(e^{-\frac{t}{P}+\frac{t}{P}-1} \right)$

> Parameter $S$ is defined as the RMSS of cells once the system reaches steady state. The RMSS at time $t$ across all cells is calculated in 3D as $$RMSS(t) = \sqrt{\left<v_x(t)^2+v_y(t)^2+v_z(t)^2\right>},$$ where the average $\left< \right>$ is over all cells. 

This seems odd. Why average over cells before taking the square root? 

Because this is a standard measure in kinetic theory of gases. 

## Check the distribution of mean squared displacement (MSD) 

```{python}
MSD_expected = 2*(S**2)*(P**2)*(np.exp(-t2/P)+t2/P-1)

# plt.hist(np.sqrt(x_end_store[:,0]**2+x_end_store[:,1]**2+x_end_store[:,2]**2))
plt.hist(np.sqrt(sd_store[-1,:]))
plt.axvline(np.sqrt(MSD_expected[-1]),c='r')
plt.xlabel('MSD')
plt.ylabel('frequency')
plt.title('Mean Squared Displacement (final)')
plt.show()
```


```{python}
plt.plot(t2,sd_store,'gray')
plt.plot(t2,np.mean(sd_store,axis=1),'b',linewidth=6,label='Mean over cells')
plt.plot(t2,(MSD_expected),'r',linewidth=3,label='Theory')
plt.xlabel('Time')
plt.ylabel('Squared Displacement and Mean')
plt.legend()
plt.show()
```

## Speeds

Show the Squared-Speed (SS) for one of the trajectories and the Root-Mean-Squared-Speed (RMSS) 
```{python}
plt.plot(t2,ss_store[:,0],label='First cell')
plt.plot(t2,np.mean(ss_store,axis=1),label='Mean over cells')
plt.xlabel('Time')
plt.ylabel('Squared Speed')
plt.legend()
plt.show()
```

Show the speed for all the trajectories and the Root-Mean-Squared-Speed (RMSS) : 

```{python}
plt.plot(t2,np.sqrt(ss_store),linewidth=0.5)
plt.plot(t2,np.sqrt(np.mean(ss_store,axis=1)),linewidth=5)
plt.xlabel('Time')
plt.ylabel('Speeds and RMSS')
plt.title('Speeds for each cell and RMSS')
plt.show()
```

Show the distribution of speeds at some time points.

```{python}
plt.hist(np.sqrt(ss_store[:,900]),20,density=True)
ss = np.linspace(0,2,101)
plt.plot(ss,((3/(2*np.pi*S**2))**(3/2))*4*np.pi*(ss**2)*np.exp(-3*ss**2/(2*S**2)),'r') 
plt.xlabel('Speed')
plt.ylabel('frequency')
plt.title('Histogram of speeds and predicted distribution')
plt.show()
```

## Plot the VACF

```{python}
plt.plot(t2,np.mean(vacf_store,axis=1))
plt.xlabel('Time')
plt.ylabel('VACF')
plt.show()
```

Log plot of VACF should go like $\ln(VACF(t)) = \ln(S^2) + \ln(e^{-t/P}) = 2 \ln(S) - t/P$: 

```{python}
plt.plot(t2,np.log(np.mean(vacf_store,axis=1)),label='ln(VACF(t))')
plt.plot(t2,2*np.log(S) - t2/P,'r',label='Theory')
plt.xlabel('Time')
plt.ylabel('ln(VACF)')
plt.legend()
plt.show()
```